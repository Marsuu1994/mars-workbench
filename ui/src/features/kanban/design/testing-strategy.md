# Kanban Testing Strategy

## Current State

### What We Have (10 test files)

| Layer | Files | Coverage |
|-------|-------|----------|
| **Schema validation** | `schemas.test.ts` | Zod schemas for create/update plan, task status, etc. |
| **Utils** | `dateUtils.test.ts`, `taskUtils.test.ts` | Pure functions: ISO week math, task grouping/sorting |
| **Services** | `boardService.test.ts`, `planService.test.ts` | Business logic with mocked DAL calls |
| **DAL** | `plans.test.ts`, `tasks.test.ts`, `planTemplates.test.ts` | Prisma query shapes with mocked client |
| **Components** | `TaskModal.test.tsx`, `ReviewChangesModal.test.tsx` | User interactions with mocked actions |

### How It Works Today

Each layer is tested in isolation with the layer below mocked:

```
Component tests  →  mock server actions
Service tests    →  mock DAL functions
DAL tests        →  mock Prisma client
```

This gives us confidence that **each unit behaves correctly in isolation**.

---

## The Gap

We don't test the **composition** of these layers. What passes through the wiring between them is unverified.

### Concrete Risks

1. **Shape mismatches** — `planService.createPlan()` passes an object to `createManyTasks()`. If the field names drift (e.g., service builds `{ for_date }` but DAL expects `{ forDate }`), both unit tests pass but the flow breaks at runtime.

2. **State consistency** — After `createPlan` runs, does `fetchBoard` actually see the generated tasks? We mock `getTasksByPlanId` to return test data, but never verify the real wiring produces that data.

3. **Idempotency assumptions** — `runDailySync` relies on `createMany({ skipDuplicates: true })`. We test that it calls `createMany` and that `createMany` calls Prisma correctly, but never verify that running the full sync twice actually produces no duplicates.

4. **Transaction atomicity** — We verify that `prisma.$transaction` is called, but not that a failure mid-transaction actually rolls back prior writes.

5. **Metric correctness** — `computeMetrics` is tested with hand-crafted task arrays, but never with tasks that were actually generated by `createPlan` → `generateTasksForTemplates`. If the generated tasks have unexpected shapes, metrics will be wrong despite passing tests.

---

## Proposed: Integration Flow Tests

### Approach

Test the **full action → service → DAL chain** with only the Prisma client replaced by an **in-memory store**.

```
Action → Service → DAL → In-Memory Prisma Store
                         ↑
                         Only this is fake
```

The in-memory store:
- Maintains state across operations (plans, tasks, planTemplates in JS arrays/maps)
- Supports the Prisma methods our DAL uses: `create`, `findFirst`, `findMany`, `createMany`, `update`, `updateMany`, `deleteMany`, `$transaction`
- Enforces `skipDuplicates` and unique constraints
- Lets us inspect state between flow steps

### Why Not Mock at the DAL Layer?

Mocking DAL functions (like our service tests do) misses the query → data shape boundary. The in-memory Prisma approach catches bugs where:
- DAL `select` clause omits a field the service needs
- DAL `where` clause doesn't match the expected filter
- `createMany` data shape doesn't match the schema

### File Structure

```
ui/src/test/
├── setup.ts                    # existing
├── prisma-mock.ts              # existing (enum-only mock)
├── prisma-memory-store.ts      # NEW: in-memory Prisma implementation
└── builders.ts                 # NEW: shared test data builders

ui/src/features/kanban/
└── __tests__/
    └── flows/
        ├── create-plan.flow.test.ts
        ├── daily-sync.flow.test.ts
        ├── end-of-period.flow.test.ts
        └── update-plan.flow.test.ts
```

---

## Flow Test Cases

### Flow 1: Create Plan

**Scenario: First-time user creates a plan with mixed template types**

Setup:
- No existing plans
- 3 task templates: "Standup" (will be DAILY×1), "Code Review" (WEEKLY×2), "Retro" (WEEKLY×1)

Steps:
1. Call `createPlan` with the 3 templates, period = current week
2. Assert plan created with status `ACTIVE`, correct `periodKey`, `lastSyncDate = today`
3. Assert 3 PlanTemplate records exist with correct type/frequency
4. Assert tasks generated:
   - 1 daily task for today (Standup), `forDate = today`, `instanceIndex = 1`
   - 2 weekly tasks (Code Review), `instanceIndex = 1, 2`
   - 1 weekly task (Retro), `instanceIndex = 1`
5. Call `fetchBoard` and assert:
   - All 4 tasks appear in TODO column
   - Metrics: `todayCount = { done: 0, total: 4 }`, `weekProjected` includes future daily projection

**Scenario: Returning user with PENDING_UPDATE plan**

Setup:
- Existing PENDING_UPDATE plan with 2 templates + 1 ad-hoc task (TODO)

Steps:
1. Call `createPlan` with same 2 templates + 1 new template, selecting the ad-hoc task
2. Assert old plan status → `COMPLETED`
3. Assert new plan is `ACTIVE`
4. Assert ad-hoc task's `planId` now points to new plan
5. Assert new template's tasks generated alongside inherited templates

**Scenario: Ad-hoc task linking/unlinking**

Setup:
- Existing PENDING_UPDATE plan with 2 ad-hoc tasks (Task A, Task B)

Steps:
1. Call `createPlan` selecting only Task A (not Task B)
2. Assert Task A has `planId = newPlan.id`
3. Assert Task B has `planId = null` (unlinked)

---

### Flow 2: Daily Sync

**Scenario: Normal daily sync generates today's tasks**

Setup:
- ACTIVE plan with 2 DAILY templates (frequency 1 each) + 1 WEEKLY template
- `lastSyncDate = yesterday`
- Yesterday's daily tasks exist (2 tasks with `forDate = yesterday`, status TODO)

Steps:
1. Call `fetchBoard` (triggers `runDailySync` internally)
2. Assert `lastSyncDate` updated to today
3. Assert 2 new daily tasks generated with `forDate = today`
4. Assert yesterday's tasks still exist and are NOT expired (1-day rollover buffer)
5. Assert board shows yesterday's tasks as "rolled over" (forDate < today)

**Scenario: Idempotency — second fetch doesn't duplicate**

Steps (continues from above):
1. Call `fetchBoard` again
2. Assert no new tasks created (total task count unchanged)
3. Assert `lastSyncDate` still = today (sync skipped)

**Scenario: Stale tasks expire after rollover window**

Setup:
- ACTIVE plan with DAILY template
- `lastSyncDate = two days ago`
- Tasks exist for 2 days ago (status TODO) and yesterday (status TODO)

Steps:
1. Call `fetchBoard` (triggers daily sync)
2. Assert tasks for 2 days ago → status `EXPIRED` (past the 1-day buffer)
3. Assert tasks for yesterday → status `TODO` still (within 1-day buffer)
4. Assert today's tasks generated fresh

**Scenario: DONE tasks are never expired**

Setup:
- Same as above but 2-days-ago tasks have status `DONE`

Steps:
1. Call `fetchBoard`
2. Assert 2-days-ago DONE tasks remain `DONE` (not expired)

---

### Flow 3: End of Period

**Scenario: Week rolls over — all incomplete tasks expire**

Setup:
- ACTIVE plan with `periodKey = last week` (e.g., "2026-W07")
- Tasks: 2 TODO, 1 DOING, 1 DONE, 1 AD_HOC (TODO)
- Current week is "2026-W08"

Steps:
1. Call `fetchBoard`
2. Assert plan status → `PENDING_UPDATE`
3. Assert TODO tasks → `EXPIRED`
4. Assert DOING task → `EXPIRED`
5. Assert DONE task → still `DONE` (never touched)
6. Assert AD_HOC task → still `TODO` (ad-hoc tasks never expire on period end)
7. Assert `fetchBoard` returns null (no ACTIVE plan)

---

### Flow 4: Update Plan

**Scenario: Add a new template to active plan**

Setup:
- ACTIVE plan with 1 DAILY template, `lastSyncDate = today`
- Board has tasks from create + daily sync

Steps:
1. Call `updatePlan` adding a new WEEKLY×2 template
2. Assert new PlanTemplate created
3. Assert 2 new WEEKLY tasks generated (`instanceIndex = 1, 2`)
4. Assert original tasks untouched
5. Call `fetchBoard` — all tasks visible, metrics updated

**Scenario: Remove a template — incomplete tasks deleted, done preserved**

Setup:
- ACTIVE plan with WEEKLY×3 template
- 3 tasks: instance 1 = DONE, instance 2 = TODO, instance 3 = DOING

Steps:
1. Call `updatePlan` removing the template
2. Assert PlanTemplate deleted
3. Assert TODO and DOING tasks deleted
4. Assert DONE task preserved (still exists, not deleted)

**Scenario: Modify template frequency**

Setup:
- ACTIVE plan with WEEKLY×2 template
- 2 tasks exist (TODO, TODO)

Steps:
1. Call `updatePlan` changing frequency from 2 → 3
2. Assert old TODO tasks deleted
3. Assert 3 new WEEKLY tasks generated
4. Assert PlanTemplate updated (frequency = 3)

---

### Flow 5: Full Lifecycle (End-to-End Sanity Check)

**Scenario: Create → use for a week → period ends → create new plan**

Steps:
1. Create plan with DAILY×1 and WEEKLY×2 and 1 ad-hoc task
2. Simulate Day 1: fetchBoard → daily tasks + weekly tasks + ad-hoc on board
3. Mark some tasks DONE
4. Simulate Day 2: advance date → fetchBoard → new daily tasks, Day 1 tasks still alive (rollover)
5. Simulate Day 3: advance date → fetchBoard → Day 1 tasks expired, Day 2 tasks alive, Day 3 tasks generated
6. Mark weekly task DONE
7. Advance to next week → fetchBoard → returns null, plan = PENDING_UPDATE
8. Verify: all non-DONE tasks expired, DONE tasks preserved, ad-hoc task still TODO
9. Create new plan selecting same templates + the surviving ad-hoc task
10. Verify: new ACTIVE plan, old plan COMPLETED, ad-hoc relinked, fresh tasks generated

This is the single most valuable test — it catches state leaks and off-by-one errors across the full lifecycle.

---

## Implementation Plan

### Phase 1: In-Memory Prisma Store

Build `prisma-memory-store.ts` that implements the subset of Prisma client methods used by our DAL:

**Models to support:** `plan`, `planTemplate`, `task`, `taskTemplate`

**Methods per model:**
- `create({ data, select? })` — insert + return
- `findFirst({ where, select?, include? })` — query by conditions
- `findMany({ where?, select?, include?, orderBy? })` — list with filters
- `createMany({ data, skipDuplicates? })` — batch insert
- `update({ where, data })` — update by ID
- `updateMany({ where, data })` — bulk update
- `deleteMany({ where })` — bulk delete

**Global methods:**
- `$transaction(fn)` — execute callback, rollback on error (snapshot + restore)
- `_reset()` — clear all data between tests
- `_seed(model, records[])` — insert test data directly

**Unique constraint enforcement:**
- PlanTemplate: `(planId, templateId)` pair must be unique
- `skipDuplicates` on createMany must actually skip

### Phase 2: Test Data Builders

Shared builders in `builders.ts`:

```ts
makeTemplate(overrides?)   → TaskTemplate with defaults
makePlanInput(overrides?)   → CreatePlan action input
```

### Phase 3: Flow Tests

Write the 4 flow test files (+ the lifecycle test), calling real action/service code against the in-memory store.

**Execution order:** Create Plan → Daily Sync → End of Period → Update Plan → Full Lifecycle

### Phase 4: Vitest Config

Add a separate vitest config or test group for flow tests so they can be run independently:

```bash
npm run test:unit    # existing unit tests
npm run test:flow    # integration flow tests
npm run test         # both
```

---

## Open Questions

1. **Server actions and `revalidatePath`** — Our actions call `revalidatePath('/kanban')` which is a Next.js function. For flow tests, should we:
   - (a) Call services directly (skip the action layer), or
   - (b) Mock `next/cache` and call actions (tests the full chain including validation)

   Recommendation: **(b)** — mock `revalidatePath` as a no-op and call actions. This tests Zod validation + the action → service wiring.

2. **Date mocking** — Daily sync and period detection depend on "today". We already mock `dateUtils.getToday()` in service tests. Flow tests should use the same approach to simulate day advancement.

3. **Transaction rollback testing** — Should we test that a failure mid-transaction actually rolls back? This requires the in-memory store to implement snapshot/restore. Worth doing for Phase 1 but not a blocker for the flow tests.
